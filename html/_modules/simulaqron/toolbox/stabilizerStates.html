
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>simulaqron.toolbox.stabilizerStates &#8212; SimulaQron 3.0.14 documentation</title>
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SimulaQron 3.0.14 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for simulaqron.toolbox.stabilizerStates</h1><div class="highlight"><pre>
<span></span><span class="c1">##########################################################################################</span>
<span class="c1">#</span>
<span class="c1"># This file contains classes for describing stabilizer states and manipulating these using</span>
<span class="c1"># Clifford operations and Pauli-measurements etc.</span>
<span class="c1">#</span>
<span class="c1"># Author: Axel Dahlberg</span>
<span class="c1">#</span>
<span class="c1">##########################################################################################</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>


<div class="viewcode-block" id="StabilizerState"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState">[docs]</a><span class="k">class</span> <span class="nc">StabilizerState</span><span class="p">:</span>
    <span class="n">bool2phase</span> <span class="o">=</span> <span class="p">{</span><span class="kc">False</span><span class="p">:</span> <span class="s2">&quot;+1&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">:</span> <span class="s2">&quot;-1&quot;</span><span class="p">}</span>

    <span class="n">bool2Pauli</span> <span class="o">=</span> <span class="p">{(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span> <span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span> <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span> <span class="s2">&quot;Z&quot;</span><span class="p">}</span>

    <span class="n">phase2bool</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;+1&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;-1&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

    <span class="n">Pauli2bool</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_symplectic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class represent a stabilizer state and allows to be manipulated using</span>
<span class="sd">        Clifford operations and Pauli-measurements.</span>

<span class="sd">        If check_symplectic=True then a check will be made that all stabilizers commute, by checking</span>
<span class="sd">        That the matrix is symplectic. Otherwise no check is made.</span>

<span class="sd">        :param data:</span>
<span class="sd">            Can be one of the following:</span>

<span class="sd">            A binary array of rank 2:</span>
<span class="sd">                A binary array representing the generators of the stabilizer group.</span>
<span class="sd">                If the array is n-by-2n a stabilizer state on n qubits will be represented.</span>
<span class="sd">                The n first columns are the X-stabilizers and the n last the Z-stabilizer.</span>
<span class="sd">                If the array is n-by-(2n+1), the last column is seen as the phase for each generator</span>
<span class="sd">                as follows:</span>
<span class="sd">                    0 -&gt; 1</span>
<span class="sd">                    1 -&gt; -1</span>

<span class="sd">            An array of rank 1 containing &#39;str&#39;:</span>
<span class="sd">                Then each string is assumed to be a generator as for example &quot;XXZIY&quot;</span>
<span class="sd">                Note that each string in the array should have the same length.</span>
<span class="sd">                If the number of strings is &#39;n&#39; then a stabilizer state on &#39;n&#39; qubits is created.</span>
<span class="sd">                If the strings have length &#39;n&#39; then it is assumed that the phase is &#39;+1&#39;.</span>
<span class="sd">                An explicit phase can be added to the start of the string as for example: &quot;-1XXXY&quot;.</span>
<span class="sd">                Creating a Bell-pair:</span>
<span class="sd">                    StabilizerState([&quot;XX&quot;, &quot;ZZ&quot;])  # The state (|00&gt; + |11&gt;) / sqrt(2)</span>

<span class="sd">            &#39;None&#39; (default):</span>
<span class="sd">                Then this is seen as a stabilizer state on no qubits, i.e. a complex number.</span>
<span class="sd">                To add a qubit to such a state one can do:</span>
<span class="sd">                    s = StabilizerState()</span>
<span class="sd">                    s.add_qubit()  # This is now in the state |0&gt;</span>

<span class="sd">            &#39;int&#39;:</span>
<span class="sd">                Then a stabilizer state on this many qubits are created, all in the state |0&gt; as:</span>
<span class="sd">                    StabilizerState(5)  # This is the then the state |00000&gt;</span>

<span class="sd">            &#39;networkx.Graph&#39;:</span>
<span class="sd">                Then the graph state corresponding to this graph will be created.</span>
<span class="sd">                This assumes that the nodes are numbered from 0 to n - 1, where n is the number of nodes.</span>
<span class="sd">                For example:</span>
<span class="sd">                    StabilizerState(networkx.complete_graph(5))  # Single qubit Clifford equiv. to a GHZ state</span>

<span class="sd">        Examples:</span>
<span class="sd">        A qubit in the state |0&gt; can be created as:</span>
<span class="sd">            StabilizerState([[0, 1]])</span>

<span class="sd">        A qubit in the state |1&gt; can be created as:</span>
<span class="sd">            StabilizerState([[0, 1, 1]])</span>

<span class="sd">        The entangled state (|00&gt; + |11&gt;)/sqrt(2) can be created as:</span>
<span class="sd">            StabilizerState([[1, 1, 0, 0],</span>
<span class="sd">                              0, 0, 1, 1]])</span>

<span class="sd">        The entangled state (|01&gt; + |10&gt;)/sqrt(2) can be created as:</span>
<span class="sd">            StabilizerState([[1, 1, 0, 0, 0],</span>
<span class="sd">                              0, 0, 1, 1, 1]])</span>
<span class="sd">        :param check_symplectic: bool</span>
<span class="sd">            Whether to check if all stabilizers commute or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">X_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">Z_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X_part</span><span class="p">,</span> <span class="n">Z_part</span><span class="p">,</span> <span class="n">phases</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">StabilizerState</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">_group</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_nr_rows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_nr_cols</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">X_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">Z_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adj_matrix</span><span class="o">.</span><span class="n">todense</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X_part</span><span class="p">,</span> <span class="n">Z_part</span><span class="p">,</span> <span class="n">phases</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="c1"># We should pre-process this entry since it contains strings and not booleans</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">op_str</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_to_operator</span><span class="p">(</span><span class="n">op_str</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If data is a length-&#39;n&#39; list or stings, &quot;</span>
                                             <span class="s2">&quot;then each string needs be of length &#39;n&#39; or &#39;n+2&#39;&quot;</span><span class="p">)</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Could not create an array of the &#39;data&#39; due to the following error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;data&#39; needs to be an array of rank 2&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="o">.</span><span class="n">shape</span>

                    <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">,</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_cols</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;data&#39; needs to be an array of dimension n x 2n or n x (2n +1)&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">check_symplectic</span><span class="p">:</span>
                    <span class="c1"># Check that all stabilizers commute, i.e. the matrix should be symplectic</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span>
                    <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">zeros</span><span class="p">,</span> <span class="n">identity</span><span class="p">],</span> <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="n">zeros</span><span class="p">]])</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

                    <span class="n">commute</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="n">P</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">commute</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All stabilizer of the group constructed from the input does not commute.&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_str_to_operator</span><span class="p">(</span><span class="n">op_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Formats a str representing an operator to a binary representation of the operator.</span>

<span class="sd">        Returns ``None`` if the string is not formatted properly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">op_str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;+1&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">op_str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;-1&quot;</span><span class="p">):</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">op_str</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">paulis</span> <span class="o">=</span> <span class="n">op_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="s2">&quot;+1&quot;</span>
            <span class="n">paulis</span> <span class="o">=</span> <span class="n">op_str</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_is_paulis</span><span class="p">(</span><span class="n">paulis</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_is_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">x_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">pauli</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">pauli</span> <span class="ow">in</span> <span class="n">paulis</span><span class="p">]</span>
        <span class="n">z_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">pauli</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">pauli</span> <span class="ow">in</span> <span class="n">paulis</span><span class="p">]</span>
        <span class="n">phase_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase</span> <span class="o">==</span> <span class="s2">&quot;-1&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x_part</span> <span class="o">+</span> <span class="n">z_part</span> <span class="o">+</span> <span class="n">phase_part</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_paulis</span><span class="p">(</span><span class="n">paulis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks that ``paulis`` is a list of strings representing Paulis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">pauli</span> <span class="ow">in</span> <span class="s2">&quot;IXYZ&quot;</span> <span class="k">for</span> <span class="n">pauli</span> <span class="ow">in</span> <span class="n">paulis</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_phase</span><span class="p">(</span><span class="n">phase</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks that ``phase`` is a valid string representing a phase</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">phase</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;+1&quot;</span><span class="p">,</span> <span class="s2">&quot;-1&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">StabilizerState</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only compare with other StabilizerState&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get the standard forms of the groups</span>
                <span class="n">this_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_gaussian_elimination</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">)</span>
                <span class="n">other_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_gaussian_elimination</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_group</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this_group</span> <span class="o">==</span> <span class="n">other_group</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;StabilizerState(np.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="s2">&quot;Stabilizer state on </span><span class="si">{}</span><span class="s2"> with the following stabilizer generators:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row_str</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">to_return</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">to_return</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_row_to_string</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">StabilizerState</span><span class="o">.</span><span class="n">bool2phase</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">to_return</span> <span class="o">+=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">bool2Pauli</span><span class="p">[(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">to_return</span>

<div class="viewcode-block" id="StabilizerState.to_string"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">:</span>
            <span class="n">to_return</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_to_string</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">to_return</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">to_return</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="StabilizerState.Pauli_phase_tracking"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.Pauli_phase_tracking">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">Pauli_phase_tracking</span><span class="p">(</span><span class="n">old_pauli</span><span class="p">,</span> <span class="n">applied_pauli</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">old_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span> <span class="ow">and</span> <span class="n">applied_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">added_phase</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="n">old_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span> <span class="ow">and</span> <span class="n">applied_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">added_phase</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="n">old_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span> <span class="ow">and</span> <span class="n">applied_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="n">added_phase</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="n">old_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span> <span class="ow">and</span> <span class="n">applied_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="n">added_phase</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">old_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span> <span class="ow">and</span> <span class="n">applied_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">added_phase</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">old_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span> <span class="ow">and</span> <span class="n">applied_pauli</span> <span class="o">==</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="n">added_phase</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">added_phase</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">added_phase</span></div>

<div class="viewcode-block" id="StabilizerState.boolean_gaussian_elimination"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.boolean_gaussian_elimination">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">boolean_gaussian_elimination</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">return_pivot_columns</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a boolean matrix returns the matrix in row reduced echelon form</span>
<span class="sd">        where entries are seen as elements of GF(2), i.e. intergers modulus 2.</span>
<span class="sd">        :param matrix: The boolean matrix</span>
<span class="sd">        :type matrix: :obj:`numpy.array`</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype: :obj:`numpy.array`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not create an array of the &#39;data&#39; due to the following error: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;data&#39; needs to be an array of rank 2&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">new_matrix</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pivot_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">non_zero_ind</span> <span class="o">=</span> <span class="n">new_matrix</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">non_zero_ind_under_h</span> <span class="o">=</span> <span class="n">non_zero_ind</span><span class="p">[</span><span class="n">non_zero_ind</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_zero_ind_under_h</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># No nonzero elements in this column</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_max</span> <span class="o">=</span> <span class="n">non_zero_ind_under_h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i_max</span> <span class="o">!=</span> <span class="n">h</span><span class="p">:</span>
                    <span class="c1"># Move the row i_max to the h row</span>
                    <span class="n">new_matrix</span><span class="p">[[</span><span class="n">h</span><span class="p">,</span> <span class="n">i_max</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_matrix</span><span class="p">[[</span><span class="n">i_max</span><span class="p">,</span> <span class="n">h</span><span class="p">]]</span>
                <span class="c1"># Add pivot row to the rest</span>
                <span class="n">pivot_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">non_zero_except_i_max</span> <span class="o">=</span> <span class="n">non_zero_ind</span><span class="p">[</span><span class="n">non_zero_ind</span> <span class="o">!=</span> <span class="n">i_max</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_zero_except_i_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_matrix</span><span class="p">[</span><span class="n">non_zero_except_i_max</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_multiply_stabilizers</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">new_matrix</span><span class="p">[</span><span class="n">h</span><span class="p">]),</span>
                        <span class="mi">1</span><span class="p">,</span>
                        <span class="n">new_matrix</span><span class="p">[</span><span class="n">non_zero_except_i_max</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="p">)</span>

                <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">return_pivot_columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_matrix</span><span class="p">,</span> <span class="n">pivot_columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_matrix</span></div>

<div class="viewcode-block" id="StabilizerState.check_symplectic"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.check_symplectic">[docs]</a>    <span class="k">def</span> <span class="nf">check_symplectic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symplectic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_multiply_stabilizers</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiplies two stabilizers together to a third one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Update the x and z stabilizers</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Update the phase</span>
        <span class="n">new_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_s</span><span class="p">,</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_multiply_compute_phase</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">new_s</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_pauli_mask</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a mask for which positions where the Pauli of the first stabilier is `p1`</span>
<span class="sd">        and the Pauli of the second stabilizer is `p2`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_paulis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">p1_bool</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">Pauli2bool</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
        <span class="n">p2_bool</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">Pauli2bool</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
        <span class="n">is_p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="p">[:</span><span class="n">num_paulis</span><span class="p">]</span> <span class="o">==</span> <span class="n">p1_bool</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">num_paulis</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p1_bool</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">is_p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">s2</span><span class="p">[:</span><span class="n">num_paulis</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2_bool</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="n">num_paulis</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p2_bool</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">is_p1</span> <span class="o">&amp;</span> <span class="n">is_p2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_i_mask</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a mask for which positions where the Paulis of the two stabilizers gives</span>
<span class="sd">        a `i`-phase.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_i</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">paulis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="s2">&quot;YZ&quot;</span><span class="p">,</span> <span class="s2">&quot;ZX&quot;</span><span class="p">]:</span>
            <span class="n">has_i</span> <span class="o">|=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_get_pauli_mask</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="o">*</span><span class="n">paulis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">has_i</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_minus_i_mask</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a mask for which positions where the Paulis of the two stabilizers gives</span>
<span class="sd">        a `-i`-phase.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_minus_i</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">paulis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;YX&quot;</span><span class="p">,</span> <span class="s2">&quot;ZY&quot;</span><span class="p">,</span> <span class="s2">&quot;XZ&quot;</span><span class="p">]:</span>
            <span class="n">has_minus_i</span> <span class="o">|=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_get_pauli_mask</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="o">*</span><span class="n">paulis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">has_minus_i</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_multiply_compute_phase</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the new phase of when multiplying two stabilizers&quot;&quot;&quot;</span>
        <span class="c1"># Compute the number of i and -i phases</span>
        <span class="n">has_minus_i</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_get_minus_i_mask</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
        <span class="n">has_i</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_get_i_mask</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
        <span class="n">num_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">has_i</span><span class="p">)</span>
        <span class="n">num_minus_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">has_minus_i</span><span class="p">)</span>
        <span class="n">has_minus_phase</span> <span class="o">=</span> <span class="p">((</span><span class="n">num_i</span> <span class="o">-</span> <span class="n">num_minus_i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">has_minus_phase</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_symplectic</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a given matrix is symplectic, i.e. if all the corresponding stabilizers commute.</span>
<span class="sd">        It is assumed that matrix is a ``2 * n + 1`` matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># num paulis</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">zeros</span><span class="p">,</span> <span class="n">identity</span><span class="p">],</span> <span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="n">zeros</span><span class="p">]])</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">commute</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="n">P</span> <span class="o">@</span> <span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">commute</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># All stabilizer of the group constructed from the input does not commute</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="StabilizerState.contains"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stabilizer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a given stabilizer is in the stabilizer group.</span>

<span class="sd">        Args:</span>
<span class="sd">            stabilizer (str or list): The stabilizer to check if it&#39;s in the group.</span>

<span class="sd">            Should either be a str of the form &quot;XXX&quot; or &quot;+1XXX&quot; or a boolean list</span>
<span class="sd">            of length ``2*n`` or ``2*n + 1`` in the same way as the input to the ``__init__``</span>
<span class="sd">            of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">,</span> <span class="n">stabilizer</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_contains</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">stabilizer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a given stabilizer is in the stabilizer group represented by the given matrix.</span>

<span class="sd">        Args:</span>
<span class="sd">            matrix (array): Boolean array of the form n x (2 * n + 1).</span>
<span class="sd">            stabilizer (str or list): The stabilizer to check if it&#39;s in the group.</span>
<span class="sd">                Should either be a str of the form &quot;XXX&quot; or &quot;+1XXX&quot; or a boolean list</span>
<span class="sd">                of length ``2*n`` or ``2*n + 1`` in the same way as the input to the ``__init__``</span>
<span class="sd">                of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">stab</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_str_to_operator</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stab</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot parse </span><span class="si">{}</span><span class="s2"> as a stabilizer.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stab</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">)</span>
        <span class="n">num_cols</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stab</span><span class="p">)</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">stab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_assert_valid_stabilizer</span><span class="p">(</span><span class="n">stab</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">)</span>

        <span class="c1"># Construct a new matrix with the stabilizer as the last row</span>
        <span class="n">extended_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">matrix</span><span class="p">,</span> <span class="p">[</span><span class="n">stab</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># First check if the stabilizer commutes with all the ones in the stabilizer group</span>
        <span class="c1"># NOTE this is since the method for boolean gaussian elimination currently</span>
        <span class="c1"># assume that all stabilizers commute</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_is_symplectic</span><span class="p">(</span><span class="n">extended_matrix</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Do boolean reduction to find the rank of the new matrix</span>
        <span class="n">extended_matrix</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">boolean_gaussian_elimination</span><span class="p">(</span><span class="n">extended_matrix</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_num_zero_rows</span><span class="p">(</span><span class="n">extended_matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_num_zero_rows</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Counts the number of rows with 0/False entries&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">row</span><span class="p">)])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_assert_valid_stabilizer</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks that ``stabilizer`` is a valid list of bools of the correct length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">stabilizer</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All entries in a stabilizer should be of type `bool`.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Stabilizer must be of length </span><span class="si">{}</span><span class="s2">, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_cols</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stabilizer</span><span class="p">)))</span>

<div class="viewcode-block" id="StabilizerState.add_qubit"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.add_qubit">[docs]</a>    <span class="k">def</span> <span class="nf">add_qubit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends a qubit in the state \|0\&gt; to the current state</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z0</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor_product</span><span class="p">(</span><span class="n">z0</span><span class="p">))</span></div>

<div class="viewcode-block" id="StabilizerState.put_in_standard_form"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.put_in_standard_form">[docs]</a>    <span class="k">def</span> <span class="nf">put_in_standard_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Puts the generators of the stabilizer group in standard form by performing Gaussiand elemination</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_gaussian_elimination</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">)</span></div>

<div class="viewcode-block" id="StabilizerState.tensor_product"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.tensor_product">[docs]</a>    <span class="k">def</span> <span class="nf">tensor_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the tensor product with another StabilizerState and returns a new</span>
<span class="sd">        StabilizerState.</span>

<span class="sd">        This can also be done using &#39;*&#39; as for example:</span>

<span class="sd">            s1 = StabilizerState([[0, 1]])  # The state \|0\&gt;</span>
<span class="sd">            s2 = StabilizerState([[0, 1]])  # The state \|0\&gt;</span>

<span class="sd">            s3 = s1 * s2  # This is then the state \|00\&gt;</span>

<span class="sd">        :param other: The other StabilizerState to perform the tensor product with</span>
<span class="sd">        :type other: :obj:`StabilizerState`</span>
<span class="sd">        :return: The tensor product of self and other</span>
<span class="sd">        :rtype: :obj:`StabilizerState`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">StabilizerState</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only perform tensor product with other StabilizerState&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">StabilizerState</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">num_qubits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this_X_stab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">]</span>
            <span class="n">this_Z_stab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">other_X_stab</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">num_qubits</span><span class="p">]</span>
            <span class="n">other_Z_stab</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">other</span><span class="o">.</span><span class="n">num_qubits</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">new_X_stab</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">this_X_stab</span><span class="p">,</span> <span class="n">other_X_stab</span><span class="p">)</span>
            <span class="n">new_Z_stab</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">this_Z_stab</span><span class="p">,</span> <span class="n">other_Z_stab</span><span class="p">)</span>

            <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">other</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">new_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">new_X_stab</span><span class="p">,</span> <span class="n">new_Z_stab</span><span class="p">,</span> <span class="n">phases</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">StabilizerState</span><span class="p">(</span><span class="n">new_group</span><span class="p">)</span></div>

<div class="viewcode-block" id="StabilizerState.to_array"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.to_array">[docs]</a>    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">standard_form</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_pivot_columns</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the numpy array representing the stabilizer group of this state.</span>
<span class="sd">        See doc-string for __init__ how the elements of this numpy array are treated.</span>
<span class="sd">        Since, the __init__ takes an array as input, given a StabilizerState &#39;s1&#39; on can do:</span>

<span class="sd">            s2 = StabilizerState(to_array(s1))</span>

<span class="sd">        and &#39;s1&#39; and &#39;s2&#39; will represent the same state.</span>

<span class="sd">        :return: The generators of this stabilizer group as a numpy array</span>
<span class="sd">        :rtype: :obj:`numpy.array`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">standard_form</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_pivot_columns</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_gaussian_elimination</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_gaussian_elimination</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="StabilizerState.apply_X"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_X">[docs]</a>    <span class="k">def</span> <span class="nf">apply_X</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the Pauli X operator to qubit &#39;position&#39; of the stabilizer state and updates the generators.</span>
<span class="sd">        :param position: The position of the qubit.</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">yz_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>

        <span class="c1"># Flip phases for Y and Z rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">yz_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">yz_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.apply_Y"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_Y">[docs]</a>    <span class="k">def</span> <span class="nf">apply_Y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the Pauli Y operator to qubit &#39;position&#39; of the stabilizer state and updates the generators.</span>
<span class="sd">        :param position: The position of the qubit.</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">xz_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>

        <span class="c1"># Flip phases for X and Z rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xz_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xz_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.apply_Z"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_Z">[docs]</a>    <span class="k">def</span> <span class="nf">apply_Z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the Pauli Z operator to qubit &#39;position&#39; of the stabilizer state and updates the generators.</span>
<span class="sd">        :param position: The position of the qubit.</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">xy_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span><span class="p">]</span>

        <span class="c1"># Flip phases for X and Y rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.apply_H"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_H">[docs]</a>    <span class="k">def</span> <span class="nf">apply_H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the H operator to qubit &#39;position&#39; of the stabilizer state and updates the generators.</span>
<span class="sd">        :param position: The position of the qubit.</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="c1"># Swap the Z and X columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="p">[</span><span class="n">position</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="p">[</span><span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">position</span><span class="p">]]</span>

        <span class="c1"># Update the phases</span>
        <span class="n">y_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">y_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">y_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.apply_K"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_K">[docs]</a>    <span class="k">def</span> <span class="nf">apply_K</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the K operator to qubit &#39;position&#39; of the stabilizer state and updates the generators.</span>
<span class="sd">        :param position: The position of the qubit.</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="c1"># Perform effective CNOT from Z column to X column</span>
        <span class="n">yz_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">yz_rows</span><span class="p">,</span> <span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">yz_rows</span><span class="p">,</span> <span class="n">position</span><span class="p">])</span>

        <span class="c1"># Update the phases</span>
        <span class="n">x_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">x_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">x_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.apply_S"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_S">[docs]</a>    <span class="k">def</span> <span class="nf">apply_S</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the S operator to qubit &#39;position&#39; of the stabilizer state and updates the generators.</span>
<span class="sd">        :param position: The position of the qubit.</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="c1"># Perform effective CNOT from X column to Z column</span>
        <span class="n">xy_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_rows</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_rows</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>
        <span class="c1"># Update the phases</span>
        <span class="n">x_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">x_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">x_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.apply_sqrt_minIX"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_sqrt_minIX">[docs]</a>    <span class="k">def</span> <span class="nf">apply_sqrt_minIX</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_K</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_Z</span><span class="p">(</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="StabilizerState.apply_sqrt_IZ"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_sqrt_IZ">[docs]</a>    <span class="k">def</span> <span class="nf">apply_sqrt_IZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_Z</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_S</span><span class="p">(</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="StabilizerState.apply_CNOT"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_CNOT">[docs]</a>    <span class="k">def</span> <span class="nf">apply_CNOT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies CNOT using qubit &#39;control&#39; as control and &#39;target&#39; as target.</span>
<span class="sd">        :param control: The control qubit</span>
<span class="sd">        :type control: int</span>
<span class="sd">        :param target: The target qubit</span>
<span class="sd">        :type control: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">control</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">control</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;control= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;target= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">control</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Control and target qubits cannot be the same&quot;</span><span class="p">)</span>

        <span class="c1"># Perform effective CNOT from the control X column to target X column</span>
        <span class="n">xy_control_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">control</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_control_rows</span><span class="p">,</span> <span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_control_rows</span><span class="p">,</span> <span class="n">target</span><span class="p">])</span>

        <span class="c1"># Perform effective CNOT from the target Z column to control Z column</span>
        <span class="n">yz_target_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">target</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">yz_target_rows</span><span class="p">,</span> <span class="n">control</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">yz_target_rows</span><span class="p">,</span> <span class="n">control</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>

        <span class="c1"># Update the phases</span>
        <span class="n">xy_control_yz_target_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">control</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">target</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>
        <span class="n">yz_control_xy_target_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">control</span> <span class="o">+</span> <span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">target</span><span class="p">])</span>
        <span class="n">not_yz_control_not_xy_target_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">control</span> <span class="o">+</span> <span class="n">n</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">target</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">rows_to_flip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">xy_control_yz_target_rows</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">yz_control_xy_target_rows</span><span class="p">,</span> <span class="n">not_yz_control_not_xy_target_rows</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">rows_to_flip</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">rows_to_flip</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.apply_CZ"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.apply_CZ">[docs]</a>    <span class="k">def</span> <span class="nf">apply_CZ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies CZ using qubit &#39;control&#39; as control and &#39;target&#39; as target.</span>
<span class="sd">        :param control: The control qubit</span>
<span class="sd">        :type control: int</span>
<span class="sd">        :param target: The target qubit</span>
<span class="sd">        :type control: int</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">control</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">control</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;control= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;target= </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (i.e. in [0, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">control</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Control and target qubits cannot be the same&quot;</span><span class="p">)</span>

        <span class="c1"># Update the phases</span>
        <span class="n">x_and_y_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">control</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">target</span><span class="p">])</span>
        <span class="n">z_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">control</span> <span class="o">+</span> <span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">target</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>
        <span class="n">rows_to_flip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x_and_y_rows</span><span class="p">,</span> <span class="n">z_rows</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">rows_to_flip</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">rows_to_flip</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Perform effective CNOT from the control X column to target Z column</span>
        <span class="n">xy_control_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">control</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_control_rows</span><span class="p">,</span> <span class="n">target</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_control_rows</span><span class="p">,</span> <span class="n">target</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span>

        <span class="c1"># Perform effective CNOT from the target X column to control Z column</span>
        <span class="n">xy_target_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[:,</span> <span class="n">target</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_target_rows</span><span class="p">,</span> <span class="n">control</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_group</span><span class="p">[</span><span class="n">xy_target_rows</span><span class="p">,</span> <span class="n">control</span> <span class="o">+</span> <span class="n">n</span><span class="p">])</span></div>

<div class="viewcode-block" id="StabilizerState.measure"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.measure">[docs]</a>    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Measures qubit &#39;position&#39; of the stabilizer state in the standard basis.</span>
<span class="sd">        If &#39;inplace=False&#39; the qubit is removed from the state, i.e. the number of qubits in the state is reduced by one</span>
<span class="sd">        If &#39;inplace=True&#39; the qubit is not removed and the number of qubits remain the same.</span>
<span class="sd">        :param position: The position of the qubit.</span>
<span class="sd">        :type position: int</span>
<span class="sd">        :param inplace: Whether to measure the qubit in place or not. (I.e. to keep it or not)</span>
<span class="sd">        :type inplace: bool</span>
<span class="sd">        :return: The measurement outcome (0 or 1, where 0 is the +1 eigenvalue and 1 is the -1)</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_qubits</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;position = </span><span class="si">{}</span><span class="s2"> if not a valid qubit position (not in [0, </span><span class="si">{}</span><span class="s2">))&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="n">tmp_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group</span>
        <span class="c1"># Create a new matrix where the X and Z columns of the corresponding qubit are the first.</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">position</span><span class="p">]</span>
        <span class="n">perm</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">])</span>
        <span class="n">perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">tmp_matrix</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[:,</span> <span class="n">perm</span><span class="p">]</span>
        <span class="c1"># Perform Gaussian elimination such that there is maximally one X or Y at the qubit position</span>
        <span class="n">tmp_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolean_gaussian_elimination</span><span class="p">(</span><span class="n">tmp_matrix</span><span class="p">)</span>

        <span class="c1"># Check if there is an X or a Y at the qubit position</span>
        <span class="k">if</span> <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># The first row (generator) of this matrix is then the only one that doesn&#39;t commute with the observabel Z</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># If outcome is 1 we need to flip phases for the other generators that has an Z at this qubit</span>
            <span class="k">if</span> <span class="n">outcome</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">z_rows</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span>
                <span class="n">tmp_matrix</span><span class="p">[</span><span class="n">z_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">tmp_matrix</span><span class="p">[</span><span class="n">z_rows</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="c1"># Simply remove first generator and columns for X and Z of this qubit</span>
                <span class="n">X_part</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
                <span class="n">Z_part_and_phase</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X_part</span><span class="p">,</span> <span class="n">Z_part_and_phase</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set first generator to be the observable</span>
                <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">outcome</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Set the rest of the first column to be identity</span>
                <span class="n">tmp_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># Swap back the X and Z columns of this qubit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Thus means that all stabilizer elements commute with the observable</span>
            <span class="c1"># and therefore that the qubit is already in |0&gt; or |1&gt;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_first_qubit_in_zero</span><span class="p">(</span><span class="n">tmp_matrix</span><span class="p">):</span>
                <span class="c1"># Qubit is in |0&gt;</span>
                <span class="n">outcome</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Qubit is in |1&gt;</span>
                <span class="n">outcome</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">tmp_matrix</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)]</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">columns_without_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">columns</span> <span class="o">!=</span> <span class="n">position</span><span class="p">,</span> <span class="n">columns</span> <span class="o">!=</span> <span class="p">(</span><span class="n">position</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
                <span class="n">tmp_matrix</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">tmp_matrix</span><span class="p">[:,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">position</span><span class="p">]),</span> <span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[:,</span> <span class="n">columns_without_position</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nr_rows</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We don&#39;t need to do anything here since the state has not changed</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group</span> <span class="o">=</span> <span class="n">tmp_matrix</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">perm</span><span class="p">)]</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="n">outcome</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_first_qubit_in_zero</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function used in measure to decide if the first qubit is in the state |0&gt; or |1&gt;.</span>

<span class="sd">        ``matrix`` should be a matrix representing the stabilizer group of a state where the first qubit is</span>
<span class="sd">        either in the state |0&gt; or |1&gt;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">stabilizer</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span> <span class="o">+</span> <span class="s1">&#39;I&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StabilizerState</span><span class="o">.</span><span class="n">_contains</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">stabilizer</span><span class="p">)</span>

<div class="viewcode-block" id="StabilizerState.find_SQC_equiv_graph_state"><a class="viewcode-back" href="../../../simulaqron.toolbox.html#simulaqron.toolbox.stabilizerStates.StabilizerState.find_SQC_equiv_graph_state">[docs]</a>    <span class="k">def</span> <span class="nf">find_SQC_equiv_graph_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_operations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a graph state single qubit Clifford equivalent to self. Method is described</span>
<span class="sd">        in quant-ph/0308151.</span>

<span class="sd">        For example:</span>
<span class="sd">            EPR_pair = [[1,1,0,0],[0,0,1,1]]</span>
<span class="sd">            S = StabilizerState(EPR_pair)</span>
<span class="sd">            G = find_SQC_equiv_graph_state(S)</span>

<span class="sd">        :param self: The StabilizerState for which we want to find the corresponding graph state</span>
<span class="sd">        :type self: :obj:`StabilizerState`</span>
<span class="sd">        :return: A networkx graph SQC equivalent to S</span>
<span class="sd">        :rtype: :obj:`networkx.classes.graph.Graph`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S_ech_form</span><span class="p">,</span> <span class="n">pivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">standard_form</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_pivot_columns</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivs</span><span class="p">)</span>
        <span class="n">pivsX</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pivs</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivsX</span><span class="p">)</span>
        <span class="n">operations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Next step is to relabel the qubits such that the pivot columns in X</span>
        <span class="c1"># are the first k columns in X-part and the Z-part.</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">pivsX</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pivsX</span><span class="p">]</span>
        <span class="n">A</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="p">[</span><span class="n">n</span><span class="p">])]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">])</span>
        <span class="n">Sp</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="p">(</span><span class="n">S_ech_form</span><span class="p">[:,</span> <span class="n">A</span><span class="p">])</span>

        <span class="c1"># Then apply Hadamards on the last n-k qubits such that X has full rank</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">Sp</span><span class="o">.</span><span class="n">apply_H</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
        <span class="n">Sp_mat</span> <span class="o">=</span> <span class="n">Sp</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)[:,</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">]</span>
        <span class="n">phase_list</span> <span class="o">=</span> <span class="n">Sp</span><span class="o">.</span><span class="n">to_array</span><span class="p">()[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Then multiply by inv(X) such that inv(X)X = I</span>
        <span class="n">Spp_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Sp_mat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">]),</span> <span class="n">Sp_mat</span><span class="p">)</span>

        <span class="c1"># Test if this was succesfull</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">Spp_mat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The X-part should be identity,but something went wrong&quot;</span><span class="p">)</span>

        <span class="c1"># then swap back (first the columns, then the rows to keep identity on the X-part)</span>
        <span class="n">Spp_mat</span> <span class="o">=</span> <span class="n">Spp_mat</span><span class="p">[:,</span> <span class="n">A</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">]]</span>
        <span class="n">Spp_mat</span> <span class="o">=</span> <span class="n">Spp_mat</span><span class="p">[</span><span class="n">A</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">Spp</span> <span class="o">=</span> <span class="n">StabilizerState</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">Spp_mat</span><span class="p">,</span> <span class="p">[</span><span class="n">phase_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[:</span><span class="n">n</span><span class="p">]]])</span>

        <span class="c1"># Spp is now a graph state with possible self loops. To remove these,</span>
        <span class="c1"># do an S on every qubit with a self loop</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Spp_mat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">n</span><span class="p">]:</span>
                <span class="n">Spp</span><span class="o">.</span><span class="n">apply_S</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="c1"># Now we remove -1 phases which might still be there</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Spp</span><span class="o">.</span><span class="n">to_array</span><span class="p">()[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">Spp</span><span class="o">.</span><span class="n">apply_Z</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">operations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="c1"># Spp is now in the form of (I,Gamma) where Gamma is the adj mat of the Graph</span>
        <span class="c1"># SQC equivalent to the stabilizer state.</span>
        <span class="n">adj_mat</span> <span class="o">=</span> <span class="n">Spp</span><span class="o">.</span><span class="n">to_array</span><span class="p">()[:,</span> <span class="n">n</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_matrix</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_operations</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">operations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">G</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SimulaQron 3.0.14 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Stephanie Wehner and Axel Dahlberg.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.3.
    </div>
  </body>
</html>